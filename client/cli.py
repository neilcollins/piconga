#!/usr/bin/python
"""PiConga CLI Module
 
   This CLI is designed to show everything important that happens to your 
   client, and also let you join, leave and manipulate congas.  It uses
   the curses library, which gives us a user interface entirely in text.
"""   

# Python imports
import curses
import subprocess
import multiprocessing

class Cli(object):
    """Class representing the CLI as a whole."""
    
    # Class constants.
    _INPUT_WIN_HEIGHT = 5
    
    class Event(object):
        """Event that may be sent to the CLI for display."""
        
        # Event types.
        TEXT = 0          # Simple text string.
        MSG_RECVD = 1     # Message received on a conga.
        CONGA_JOINED = 2  # Client has joined a conga.
        CONGA_LEFT = 3    # Client has left a conga.
        LOST_CONN = 4     # Client lost connection to the server.
         
        # List of all allowed events.
        allowed_events = [TEXT, MSG_RECVD, CONGA_JOINED,
                          CONGA_LEFT, LOST_CONN]
        
        def __init__(self, event_type, text):
            """Constructor.  Store input parameters."""
            
            self.type = event_type
            self.text = text
            self.printed = False
            
            return
    

    class Action(object):
        """Action generated by the CLI."""
        
        # Action types.
        QUIT = 0          # Exit the client.
        JOIN_CONGA = 1    # Join a conga.
        LEAVE_CONGA = 2   # Leave a conga.
        SEND_MSG = 3      # Send a message on the conga.
        BEGIN_ENCRYPT = 4 # Start using encryption on messages.
        END_ENCRYPT = 5   # Stop using encryption on messages.
        
        def __init__(self, action_type, params):
            """Constructor.  Store action type and dictionary of params."""
            
            self.type = action_type
            self.params = params
            
            return
            
    # Private functions.
    
    def __init__(self):
        """Constructor."""
        
        (self._rows, self._cols) = self._get_term_dimensions()
        self._event_win = None
        self._input_win = None
        self._event_queue = multiprocessing.Queue()
        self._action_queue = multiprocessing.Queue()
        
        return
        
        
    def _get_term_dimensions(self):
        """Return the current dimensions of the terminal."""
        
        dimens_text = subprocess.check_output(["stty", "size"]).split()
        dimensions = [int(token) for token in dimens_text]
        
        return tuple(dimensions)
     
    
    def _resize_windows(self, event_win, input_win):
        """Get the current terminal dimensions, and if they are different 
        from the currently stored dimensions, resize the windows to fill the
        screen.
        """
        (rows, cols) = self._get_term_dimensions()
        if ((rows == self._rows) and (cols == self._cols)):
            return
        else:
            self._rows = rows
            self._cols = cols
            
            # The event window fills the screen width and goes from the top of
            # the screen to the top of the input window.
            event_win_height = self._cols - self._INPUT_WIN_HEIGHT
            event_win.move(0, 0)
            event_win.resize(event_win_height, self._cols)
            
            # The input window also fills the screen width, and goes from the
            # bottom of the input wondow to the bottom of the screen.
            input_win.move(event_win_height, 0)
            input_win.resize(self._INPUT_WIN_HEIGHT, self._cols)
        
        return
    
    
    def _process_event(self, event):
        """Take appropriate action for a received event."""
        
        ### MORE CODE TO GO HERE
        
        
    def _process_input(self, input):
        """Process a keypress from the user."""
        
        ### MORE CODE TO GO HERE
    
    
    def _cli_loop(self, event_win, input_win):
        """Main CLI loop.  Display any new events and look for any user input.
        
        Parameters: event_win  - Window object representing the pane that
                                 displays events.                                 
                    input_win  - Window object representing the pane that takes
                                 input from the user.
        Returns:    Nothing.
        """
        while True:
            # First, resize the windows if the user has resized the terminal
            # since the last time round the loop.
            self._resize_windows(event_win, input_win)
            
            # Redraw the border between the windows.
            input_win.hline(0, 0, "=", self._cols)

            # Get an event off the queue and process it, if there is one.
            try:
                next_event = self._event_queue.get(block=False)
                self._process_event(next_event)
            except multiprocessing.Queue.Empty:
                next_event = None

            # Get user input and process it, if there is any.
            input = input_win.getch()
            if input != -1:
                self._process_input(input)
                
            # Redraw both the windows.
            event_win.refresh()
            input_win.refresh()
            
        return
        
        
    def _start_cli(self, main_window):
        """Create the various CLI windows and kick off the main loop."""
        
        # First create the event window that receives events.  The window
        # starts at zero-size, we will resize it in the main loop.
        event_win = main_window.subwin(begin_y=0,
                                       begin_x=0,
                                       nlines=0,
                                       ncols=0)
        
        # Now create the input window, which displays the menu and takes input
        # from the user.  This also starts at zero-size and will be resized.
        input_win = main_window.subwin(begin_y=0,
                                       begin_x=0,
                                       nlines=0
                                       ncols=0)
        
        # The input window needs to respond to input instantly.
        input_win.nodelay(1)
        
        # Start off the main loop.
        self._cli_loop(event_win, input_win)
        
        return
        
        
    # Public functions.
    
    def run(self):
        """Start the CLI."""
        curses.wrapper(self._start_cli)
        
        return
        
        
    def add_event(self, event_type, text):
        """Add an event to the queue to be displayed on the CLI.
        
        Parameters: event_type  - Type of event to be displayed.  One of the
                                  event type class constants.
                    text        - Text associated with this event.  Normal
                                  string.
        Returns:    Nothing.
        """
        
        # Check that the event is permitted.
        assert event_type in self.Events.allowed_events
        
        # Add the event to the queue.
        event = self.Event(event_type, text)
        self._event_queue.put(event)
        
        return
        
        
    def get_action(self):
        """Check for any actions sent by the CLI.
        
        Returns an Action, or None if the queue is empty.
        """
        
        try:
            action = self._action_queue.get(block=False)
        except multiprocessing.Queue.Empty:
            action = None
            
        return action
        